## 描述
js的阻塞,整体与css类似
唯一的区别在于css的解析是可预测的
而js的解析不可预测,他可能包括修改dom,乃至动态加载


## 环境
那这里,我们只探讨与加载有关的现象,比如
在内联的js中,如果动态请求css,对浏览器会产生如何影响？

## 现象
执行`node index.js`，在浏览器中输入`http://127.0.0.1:3000/`
这里可观察到的现象非常明显
- 显示1后停顿1s以加载css
- 此时加载css并不阻止渲染
- 直到下载完css,loading状态才结束

如果我们取消css的1s1行的状态，在node中加入如下代码
```javascript
    if(path == './1.css'){
        socket.write(str)
        socket.destroy();
        return
    }
```
也可以观察到
- css结束后立刻渲染
- css加载完执行onload

## 解释
解释这几个现象并不复杂,点击performance
- 在appendChild中找到了`Send Request`方法

换句话讲,动态加载取消了css的阻塞特性
这里要强调一个概念,对于html渲染而言,他有两大周期
一个叫加载期,一个叫交互期
这两大周期主要与消息队列的优先级有关
不过到目前,我们可以简单的把加载期在区分为网络协调和提前交互两个阶段
也就是我们一般认为的浏览器转loading的阶段并非不能交互,除非是开始的大白屏
而交互阶段是不存在阻塞问题的
没错,css加载阻塞特指的是加载期的渲染现象

当然,动态加载也包括无线嵌套的内容,比如外联的js,动态加载js与css
当然,这些更多的是与渲染有关,就网络而言,区别不大


动态加载css并不是特别好的实例,它会让用户看明显的变化
不过动态加载js,就是另一回事了

了解了这些,应该也可以清楚
为什么有时候会要求script放在表头,使用async与defer处理
而非直接放在body后

## 总结
最后总结一下
js的阻塞与css阻塞一致
也是加载完后,统一进行解析
如果有动态加载,属于交互期事件,不存在我们要讨论的加载阻塞问题