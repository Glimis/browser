## 描述
这一期我们探讨除了js/css以外的其他资源
其他资源包括图片,音频,视频,甚至iframe系列
这里我们以图片为例

## 环境
依然是1s一行,针对于图片需要传递字节流,这里我们将图片切分,进行5s的传输

## 现象
执行`node index.js`，在浏览器中输入`http://127.0.0.1:3000/`
这里可观察到的现象非常明显
- img不会阻塞请求
- 图片收到后,按块进行加载
- 直到下载完图片,loading状态才结束
- 超过6个链接,请求会加长Stalled时间


## 解释
解释这几个现象并不复杂，点击performance

- 图片收到后,按块进行加载
找到某一个Receive Data,后续渲染流程
当然,有的渲染流程可能会合并

- 依然是parse HTML前进行的Send Request请求
预加载 不解释

至于6个链接,这就是http的规范和良好软件的默认
简单地说就是tcp链接会过多的占用服务器资源
http建议最多2个tcp链接
当然,2个只是建议,至少现在chrome是6个

既然存在多任务限制,又有阻塞与非阻塞的区分
有个小问题就是浏览器是否会判断优先级
这里我们假设阻塞型是高优先级,非阻塞型是低优先级
那当他们同时请求时,作为tcp是以顺序还是以权重进行排队?  --> index2.html

输入index2.html
毫无疑问是按顺序加载

了解了这些也就了解了图片懒加载的原因
也再次明确了
为什么有时会要求script放在header而非body尾部

## 总结
最后总结一下
js的阻塞与css阻塞一致
也是加载完后,统一进行解析
如果有动态加载,属于交互期事件,不存在我们要讨论的加载阻塞问题